# H5、C3
## H5新特性
1、H5新增了一些语义化标签：nav、aside、footer、section等  
2、新增表单的一些类型：color、email、month、week等  
3、新增音频视频标签  
4、新增Canvas标签  
5、localStorage、sessionStorage实现浏览器存储  
6、可以通过dragable进行元素拖放  
7、可以通过getCurrentPosition获取用户定位  
8、WebSocket实现长链接通讯  
## BFC
块级格式化上下文，它是页面上的一块渲染区域，有自己的一套渲染规则。它决定了子元素如何定位，以及其它元素的相互作用和关系。
翻译成白话就是：BFC可以把它看做一个容器，不管容器内如何翻江倒海，都不会影响容器外部元素的布局。
触发条件：
- body元素
- float属性除了none
- position为absolute、fixed
- display为 inline-block、table-cells、flex
- overflow除了visible

特性和应用：
1、边距塌陷。可以放在不同的BFC容器中  
2、文字环绕效果。利用浮动元素的BFC特性  
3、容器内包裹浮动元素，元素不会占位。这时候触发容器BFC就会是元素占位  
## C3新特性
- 新增伪类选择器：nth-child
- border-radius、background-size、text-shadow、box-shadow
- 动画：关键帧@keyframes
- 过度：transition
- 媒体查询：@media
## 一像素问题
+ 通过伪类和scaleY(0.5)实现边框
+ 通过box-shadow通过阴影实现：box-shadow: inset 0px -1px 1px -1px black;

# 网络协议 & 浏览器
## 输入URL到页面的呈现
https://github.com/DDYMZL/blog/blob/main/%E5%AD%A6%E4%B9%A0/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98.md
## 浏览器缓存
强缓存：向浏览器缓存发起查找请求结果，根据该请求结果返回的缓存规则，决定是否使用该缓存结果。以前用expires，由于是用户端时间和服务器时间作对比，如果有差异就不使用缓存，现在用Cache-Control。且后者优先级大于前者。
协商缓存：当强缓存失效后，浏览器就会启用协商缓存，携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用该缓存，若缓存失败则重新获取，再存入浏览器缓存中，生效则返回304，重新使用该缓存
## 常见的http状态码
2**：成功，操作被成功接收并处理
- 200：成功
- 204：成功，但没数据返回

3**：重定向，需要进一步的操作以完成请求
- 304：资源未作修改，资源被缓存

4**：客户端错误，请求包含语法错误或无法完成请求
- 400：客户端请求的语法错误，服务器无法理解
- 403：服务器理解请求客户端的请求，但是拒绝执行此请求
- 404：服务器无法根据客户端的请求找到资源

5**：服务器错误，服务器在处理请求的过程中发生了错误
- 500：服务器内部错误，无法完成请求
## 前端安全（XSS、CSRF）
XSS：跨站脚本攻击，会窃取用户的cookie、通过脚本影响页面结构、跳转到别的页面等。
- 对用户输入的内容进行过滤
- 去除script标签等关键字
- 限制用户输入的长度

CSRF：跨站请求伪造。盗用用户登录状态、冒充用户完成操作或者修改数据
- 添加验证码，输入验证码才能请求
- 在请求头添加token，在请求头放入攻击者不能伪造的信息且该信息不存在与cookie之中
## 前端跨域
同源策略中，协议、域名、端口三者有一个不一致就会引发跨域。
CORS后端响应头Access-Control-Allow-Origin与前端请求头中的Origin设置一样的域名就可以进行请求
## 原生ajax请求
1、创建XMLHttpRequest对象
var xhr = new XMLHttpRequest();
2、调用open方法，规定请求的类型、URL以及是否异步处理请求
xhr.open("POST","/try/ajax/demo_post2.php",true);
3、添加请求头，请求的参数的格式【post请求需要】
xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded");
4、发送请求
xhr.send("fname=Henry&lname=Ford");
## cookie, session, token, localstorage, sessionstorage
cookie：大小5k左右，存储在客户端
session：存储在服务端
localstorage：大小5M左右
sessionstorage：大小5M左右
## TCP连接(三次握手, 四次挥手)

# 性能优化
## 图片优化的方式
## 500张图片，如何实现预加载优化
## 减少http请求的方式
## webpack如何配置大型项目

# Vue
## Vue2、Vue3双向绑定的实现
## v-for中为啥不推荐index作为key
## Vite新特性
## Vue3新特性
## Vue的diff算法
## computed原理
## Vue中computed和methods的区别
## hash和history的区别
## v-if实现
## vue用了哪些算法
## vue与react区别
## vuex
## nextTick原理

# JS
## let, var, const 区别
## ES6新特性
## js的数据类型有哪些，值是如何存储的
## 原型链
## 闭包
## arguments对象
## JS创建对象的几种方式
## 什么是事件委托？事件传播？事件捕获？事件冒泡？
## 节流和防抖
## JS延迟加载
## 作用域和作用域链
## this、call、apply和bind
## new的原理
## async/await是怎么实现的？优缺点
## 继承
## JS有哪些规范？AMD和CMD的区别
## ES6 模块与 CommonJS 模块、AMD、CMD 的差异
## JS运行机制
## Event-loop
## 暂时性死区
## Axios
## Promiss
+ 关于promise.all跟promise.race
+ promise原理
## webpack
+ webpack5的了解，有用过那些webpack5的插件

# 项目问题
## 虚拟列表